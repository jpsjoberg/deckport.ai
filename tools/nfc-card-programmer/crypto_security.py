#!/usr/bin/env python3
"""
🔒 NTAG 424 DNA Maximum Security Implementation
Advanced cryptographic features for clone-proof cards
"""

import hashlib
import hmac
import secrets
from typing import Dict, Tuple, Optional
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os

class NTAG424CryptoManager:
    """Maximum security crypto manager for NTAG 424 DNA cards"""
    
    def __init__(self, master_key_path: str = "master_key.bin"):
        self.backend = default_backend()
        self.master_key_path = master_key_path
        self._master_key = self._load_or_create_master_key()
    
    def _load_or_create_master_key(self) -> bytes:
        """Load or create 256-bit master key"""
        if os.path.exists(self.master_key_path):
            with open(self.master_key_path, 'rb') as f:
                key = f.read()
                if len(key) == 32:  # 256 bits
                    print("🔑 Loaded existing master key")
                    return key
        
        # Create new master key
        master_key = secrets.token_bytes(32)  # 256-bit key
        with open(self.master_key_path, 'wb') as f:
            f.write(master_key)
        os.chmod(self.master_key_path, 0o600)  # Secure permissions
        print("🔑 Created new 256-bit master key")
        return master_key
    
    def derive_card_keys(self, card_uid: str) -> Dict[str, bytes]:
        """Derive unique keys for each card using HKDF"""
        uid_bytes = bytes.fromhex(card_uid.replace(':', ''))
        
        keys = {}
        key_types = ['AUTH', 'ENC', 'MAC', 'DATA']
        
        for key_type in key_types:
            # Use HKDF to derive unique 128-bit keys
            info = f"DECKPORT_NTAG424_{key_type}_{card_uid}".encode()
            
            hkdf = HKDF(
                algorithm=hashes.SHA256(),
                length=16,  # 128-bit keys for NTAG 424 DNA
                salt=uid_bytes,
                info=info,
                backend=self.backend
            )
            
            keys[key_type.lower()] = hkdf.derive(self._master_key)
        
        return keys
    
    def generate_challenge(self) -> bytes:
        """Generate cryptographically secure 16-byte challenge"""
        return secrets.token_bytes(16)
    
    def calculate_expected_response(self, card_uid: str, challenge: bytes) -> bytes:
        """Calculate expected HMAC response for challenge"""
        keys = self.derive_card_keys(card_uid)
        mac_key = keys['mac']
        
        # Create HMAC-SHA256 response
        h = hmac.HMAC(mac_key, hashes.SHA256(), backend=self.backend)
        h.update(challenge)
        h.update(card_uid.encode())  # Include UID in MAC
        
        return h.finalize()[:16]  # Truncate to 16 bytes for NTAG 424
    
    def encrypt_card_data(self, card_uid: str, data: bytes) -> Tuple[bytes, bytes]:
        """Encrypt data for storage on card"""
        keys = self.derive_card_keys(card_uid)
        enc_key = keys['enc']
        
        # Generate random IV
        iv = secrets.token_bytes(16)
        
        # AES-128 CBC encryption
        cipher = Cipher(algorithms.AES(enc_key), modes.CBC(iv), backend=self.backend)
        encryptor = cipher.encryptor()
        
        # Pad data to 16-byte blocks
        pad_len = 16 - (len(data) % 16)
        padded_data = data + bytes([pad_len] * pad_len)
        
        encrypted = encryptor.update(padded_data) + encryptor.finalize()
        
        return encrypted, iv
    
    def decrypt_card_data(self, card_uid: str, encrypted_data: bytes, iv: bytes) -> bytes:
        """Decrypt data from card"""
        keys = self.derive_card_keys(card_uid)
        enc_key = keys['enc']
        
        # AES-128 CBC decryption
        cipher = Cipher(algorithms.AES(enc_key), modes.CBC(iv), backend=self.backend)
        decryptor = cipher.decryptor()
        
        padded_data = decryptor.update(encrypted_data) + decryptor.finalize()
        
        # Remove padding
        pad_len = padded_data[-1]
        return padded_data[:-pad_len]
    
    def create_secure_ndef_url(self, card_uid: str, base_url: str) -> str:
        """Create dynamic authenticated URL for NTAG 424 DNA"""
        keys = self.derive_card_keys(card_uid)
        
        # Create URL with cryptographic parameters
        # This will be dynamically generated by the card's crypto engine
        secure_url = f"{base_url}/verify/{card_uid}?auth=DYNAMIC_CRYPTO"
        
        return secure_url
    
    def verify_card_authenticity(self, card_uid: str, challenge: bytes, response: bytes) -> bool:
        """Verify card's cryptographic response"""
        try:
            expected = self.calculate_expected_response(card_uid, challenge)
            return hmac.compare_digest(expected, response)
        except Exception as e:
            print(f"❌ Crypto verification failed: {e}")
            return False
    
    def get_card_auth_data(self, card_uid: str) -> Dict[str, str]:
        """Get authentication data for database storage"""
        keys = self.derive_card_keys(card_uid)
        
        return {
            'auth_key_hash': hashlib.sha256(keys['auth']).hexdigest(),
            'enc_key_hash': hashlib.sha256(keys['enc']).hexdigest(),
            'mac_key_hash': hashlib.sha256(keys['mac']).hexdigest(),
            'issuer_key_ref': hashlib.sha256(card_uid.encode() + self._master_key).hexdigest()[:32]
        }

# Global crypto manager instance
crypto_manager = NTAG424CryptoManager()

def get_crypto_manager() -> NTAG424CryptoManager:
    """Get the global crypto manager instance"""
    return crypto_manager
